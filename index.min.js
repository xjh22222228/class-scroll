const t="scrollAppeared";function e(t){t=t||[],this.targets=t.map((t=>({...t,_classNames:t.className.split(/\s/).filter(Boolean)}))),this.observers=[]}function s(){this.observers.forEach((t=>{t?.observer?.disconnect?.()})),this.observers=[]}e.prototype.init=function(){for(let e=0;e<this.targets.length;e++){const s=this.targets[e],o={root:s.root,rootmargin:s.rootmargin,threshold:s.threshold||0},r=new IntersectionObserver((e=>{const o=e[0].target,a="true"===o.dataset[t];if(e[0].intersectionRatio<=0)return a&&(r.disconnect(),o.removeAttribute("data-scroll-observer"),o.removeAttribute("data-scroll-appeared")),void s?.onHidden?.(e);s._classNames[0]&&o.classList.contains(s._classNames[0])||(a||(o.dataset[t]="true"),s._classNames.forEach((t=>{s.delay?setTimeout((()=>{o.classList.contains(t)||o.classList.add(t)}),s.delay):o.classList.contains(t)||o.classList.add(t)})),s?.onVisible?.(e))}),o),a="object"==typeof s.el?s.el:document.querySelector(s.el);a&&(a.dataset.scrollObserver="true",r.observe(a),this.observers.push({target:a,observer:r}))}},e.prototype.destroy=s,e.prototype.disconnect=s;export{e as default};
